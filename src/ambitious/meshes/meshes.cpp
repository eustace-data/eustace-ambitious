#include "ambitious/versions/versions.hpp"
VERSIONS_ADD(meshes_cpp, "$Revision: 1299 $")

#include "ambitious/debuglog/debuglog.hpp"
#include "ambitious/meshes/meshes.hpp"
#include "ambitious/ncdf/ncdf_helper.hpp"
#include <mpi.h>

#include "ambitious/to_string/to_string.hpp"

// uncomment to disable assert()
// #define NDEBUG
#include <cassert>



int64_t get_macro_triangle_index(int64_t micro_index,
				 int64_t micro_level,
				 int64_t macro_level)
{
  assert(macro_level <= micro_level);
  if (macro_level == micro_level) {
    return micro_index;
  } else {
    return (micro_index >> ((micro_level - macro_level) << 1));
  }
}

int64_t get_micro_triangle_index(int64_t macro_index,
				 int64_t macro_level,
				 int64_t micro_level)
{
  assert(macro_level <= micro_level);
  if (macro_level == micro_level) {
    return macro_index;
  } else {
    // x0*4^D
    return (macro_index << ((micro_level - macro_level) << 1));
  }
}
int64_t get_micro_triangle_index(int64_t macro_index,
				 int64_t macro_level,
				 int64_t micro_level,
				 int64_t corner)
{
  assert(macro_level <= micro_level);
  if (macro_level == micro_level) {
    return macro_index;
  } else {
    // x0*4^D + c*(4^D-1)/3
    return ((macro_index << ((micro_level - macro_level) << 1)) +
	    ((corner << ((micro_level - macro_level) << 1)) - corner) / 3);
  }
}

int64_t get_micro_in_macro_triangle_index(int64_t micro_index,
					  int64_t micro_level,
					  int64_t macro_level,
					  bool recursive)
{
  assert(macro_level <= micro_level);
  if (macro_level == micro_level) {
    return 0;
  } else {
    if (recursive) {
      // Remainder calculated by bitwise AND.
      int64_t size = ((micro_level - macro_level) << 1) - 1;
      return micro_index & size;
    } else {
      return get_macro_triangle_index(micro_index, micro_level, macro_level+1) & 3;
    }
  }
}


fmesh::TriangleLocator* initialise_locator(const fmesh::Mesh& M)
{
  int the_dimensions[] = {0, 1};
  std::vector<int> dimensions(the_dimensions,
			      the_dimensions +
			      sizeof(the_dimensions) / sizeof(int) );
  return new fmesh::TriangleLocator(&M, dimensions, true);
}

void initialise_locators_helper(std::vector<fmesh::TriangleLocator* >& locators,
				std::vector<fmesh::Mesh >& meshes,
				TimerHierarchy* timer) {
  locators.resize(meshes.size());
  for (size_t index = 0; index < meshes.size(); ++index) {
    if (timer != NULL) {
      timer->tic("Locator for mesh #" + to_string(index));
    }
    locators[index] = initialise_locator(meshes[index]);
    if (timer != NULL) {
      timer->toc();
    }
  }
}



/** Map between CW/CCW triangle ordering in the subdivision scheme.
 *
 * For each triangle subdivision, the local indices are mapped according to
 * `0 -> 0`, `1 -> 2`, `2 -> 1`, and `3 -> 3`.
 * This reordering is done within each of the 20 level-0 macro-triangles.
 */
int64_t triangle_index_swapwise(int64_t triangle_index, int64_t level)
{
  int64_t new_index = get_macro_triangle_index(triangle_index, level, 0);
  for (int64_t macro_level=0; macro_level < level; ++macro_level) {
    int64_t sub_index = get_micro_in_macro_triangle_index(triangle_index, level, macro_level, false);
    new_index = new_index*4 + 2*(sub_index % 2) + (sub_index / 2);
  }
  return new_index;
}



/** Build a subdivided icosahedron from stored files generated by a Python script
 *
 * The Python version stores the triangle-vertex information and sub-triangles clockwise:
 *
 *                1
 *                /\
 *               /  \
 *             e0    e1
 *             /  t1  \
 *            /        \
 *          “2”---e2---“0”
 *           /\         /\
 *          /  \  t3   /  \
 *        e0    e1   e0    e1
 *        /  t0  \   /  t2  \
 *       /        \ /        \
 *     0/---------“1”---------\2
 *
 * The C++ code stores counterclockwise,
 * which would be the following:
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *     Macro-triangle: 0 2 1
 *     t0:  0  "1" "2"
 *     t1: "2" "0"  1
 *     t2: "1"  2  "0"
 *     t3: "0" "2" "1"
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Renumbering the local node references,
 * as well as the triangle orders:
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *                2
 *                /\
 *               /  \
 *              /    \
 *             /  t2  \
 *            /        \
 *          “1”--------“0”
 *           /\         /\
 *          /  \  t3   /  \
 *         /    \     /    \
 *        /  t0  \   /  t1  \
 *       /        \ /        \
 *     0/---------“2”---------\1
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * The C++ counterclockwise storage becomes:
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 * Macro-triangle: 0 1 2
 * t0:  0  "2" "1"
 * t1: "2"  1  "0"
 * t2: "1" "0"  2
 * t3: "0" "1" "2"
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Subdivision level A < B, T_B is the level B triangle index.
 * Then the macro-triangle T_A containing T_B is given by
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *   T_A = (T_B >> ((B-A) << 1))
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 * T_A == 0 is subdivided into T_{A+1} = 0,1,2,3
 * T_A == 1 is subdivided into T_{A+1} = 4,5,6,7
 * etc
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * It's not clear what the global order of the vertices are, since
 * that emerges from the edge construction in the Python code, but
 * they do at least fulfil V_0 < V_1 < V_2 < ..., where V_. are the
 * extra vertices added at each subdivision level.  The order of the
 * vertices is kept intact; only the triangle and per-triangle
 * orderings are changed to CCW order in the C++ code.
 *
 * Does not initialise the vertex_index_ and triangle_index*_
 * information for bilevel objects; this must be done by a call to
 * reorganise_from_python.
 */
void initialise_mesh_from_python(fmesh::Mesh& mesh, int64_t level, const std::string& fileroot) {
  EUSTACE::MeshReader reader;
  std::string filename = fileroot + to_string(level) + ".nc";
  try {
    reader.Read(filename.c_str());
  } catch (const EUSTACE::MeshReaderException&) {
    std::cerr << "Error reading file " << filename << std::endl;
    exit(1);
  }

  const std::vector<double>& points = reader.Points();
  const std::vector<int32_t>& triangles = reader.Triangles();
  int64_t num_points = points.size() / 3;
  int64_t num_triangles = triangles.size() / 3;

  fmesh::Matrix3double S_input;
  fmesh::Matrix3int TV_input;
  for (int64_t point_index = 0; point_index < num_points; point_index++) {
    S_input(point_index)[0] = points[3*point_index  ];
    S_input(point_index)[1] = points[3*point_index+1];
    S_input(point_index)[2] = points[3*point_index+2];
  }

  // Triangles are stored CW in the files but CCW in fmesher.
  // Need to map indices from file to fmesher.
  for (int64_t file_triangle_index = 0; file_triangle_index < num_triangles; file_triangle_index++) {
    int64_t triangle_index = triangle_index_swapwise(file_triangle_index, level);
    TV_input(triangle_index)[0] = triangles[3*file_triangle_index  ];
    TV_input(triangle_index)[1] = triangles[3*file_triangle_index+2];
    TV_input(triangle_index)[2] = triangles[3*file_triangle_index+1];
  }

  mesh.type(fmesh::Mesh::Mtype_sphere);
  mesh.S_set(S_input);
  mesh.TV_set(TV_input);
}


void initialise_meshes_from_python(std::vector<fmesh::Mesh >& meshes,
				   const std::vector<int64_t>& levels,
				   const std::string& fileroot,
				   TimerHierarchy* timer) {
  meshes.resize(levels.size());
  for (size_t index = 0; index < levels.size(); ++index) {
    if (timer != NULL) timer->tic("Mesh level " + to_string(levels[index]));
    initialise_mesh_from_python(meshes[index], levels[index], fileroot);
    if (timer != NULL) timer->toc();
  }
}





// MPI_COMM_WORLD
// MPI_INFO_NULL
void export_mesh_to_pnetcdf(fmesh::Mesh& mesh, const std::string& filename,
                            MPI_Comm mpi_comm_, MPI_Info mpi_info_) {
  std::string vertex_dim_name = "Vertex";
  std::string triangle_dim_name = "Triangle";
  std::string index_dim_name = "Index";
  std::string vertex_name = "loc";
  std::string triangle_name = "tv";
  std::string vertex_long_name = "Vertex coordinates";
  std::string triangle_long_name = "Triangle-Vertex graph";
  std::string vertex_units = "m / earth radius";
  std::string triangle_units = "vertex index";

  int rank = 0;
  MPI_Comm_rank(mpi_comm_, &rank);

  /* Create the file. */
  NCHelper nc;
  nc.set_mpi(mpi_comm_, mpi_info_).err();
  int mode = NC_CLOBBER; // | NC_64BIT_DATA; // Don't need big variables here
  nc.create(filename, mode).err();
  
  /* Define the dimensions. */
  nc.def_dim(vertex_dim_name, mesh.nV()); nc.err();
  nc.def_dim(triangle_dim_name, mesh.nT()); nc.err();
  nc.def_dim(index_dim_name, 3); nc.err();

  /* Define coordinate netCDF variables. They will hold the
     index information. A
     varid is returned for each.*/
  nc.def_var(vertex_dim_name, NC_INT, vertex_dim_name); nc.err();
  nc.def_var(triangle_dim_name, NC_INT, triangle_dim_name); nc.err();
  nc.def_var(index_dim_name, NC_INT, index_dim_name); nc.err();

  nc.put_att_text(vertex_dim_name, "units", vertex_dim_name).err();
  nc.put_att_text(triangle_dim_name, "units", triangle_dim_name).err();
  nc.put_att_text(index_dim_name, "units", index_dim_name).err();

  /* Define the netCDF variables. The dimids array is used to pass
     the dimids of the dimensions of the variables.*/
  std::vector<std::string> dim_ids(2);
  dim_ids[0] = vertex_dim_name;
  dim_ids[1] = index_dim_name;
  nc.def_var(vertex_name, NC_DOUBLE, dim_ids); nc.err();
  dim_ids[0] = triangle_dim_name;
  dim_ids[1] = index_dim_name;
  nc.def_var(triangle_name, NC_INT, dim_ids); nc.err();

  /* Define units attributes for vars. */
  nc.put_att_text(vertex_name, "units", vertex_units).err();
  nc.put_att_text(triangle_name, "units", triangle_units).err();
  nc.put_att_text(vertex_name, "long_name", vertex_long_name).err();
  nc.put_att_text(triangle_name, "long_name", triangle_long_name).err();

  /* End define mode. */
  nc.enddef().err();

  if (rank == 0) {
  /* Write the dimension variable data.*/
  std::vector<int> dim_var(mesh.nV());
  for (int64_t i = 0; i < (int64_t)mesh.nV(); ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(vertex_dim_name, dim_var.data()).err();
  dim_var.resize(mesh.nT());
  for (int64_t i = 0; i < (int64_t)mesh.nT(); ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(triangle_dim_name, dim_var.data()).err();
  dim_var.resize(3);
  for (int64_t i = 0; i < 3; ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(index_dim_name, dim_var.data()).err();
 
  nc.iput_var<double>(vertex_name, mesh.S().raw()).err();
  nc.iput_var<int>(triangle_name, mesh.TV().raw()).err();

  }

  LOG_("before waiting, rank = " << rank << std::endl);
  nc.wait_all().stat();
  LOG_("after waiting, rank = " << rank << std::endl);

  MPI_Barrier(mpi_comm_);

  /* Close the file. */
  nc.close().err();
  LOG_("closed, rank = " << rank << std::endl);
 }


void export_mesh_to_netcdf(fmesh::Mesh& mesh, const std::string& filename) {
  std::string vertex_dim_name = "Vertex";
  std::string triangle_dim_name = "Triangle";
  std::string index_dim_name = "Index";
  std::string vertex_name = "loc";
  std::string triangle_name = "tv";
  std::string vertex_long_name = "Vertex coordinates";
  std::string triangle_long_name = "Triangle-Vertex graph";
  std::string vertex_units = "m / earth radius";
  std::string triangle_units = "vertex index";
  
  /* Create the file. */
  NCHelper nc;
  int mode = NC_CLOBBER; // | NC_64BIT_DATA; // Don't need big variables here
  nc.create(filename, mode).err();
  
  /* Define the dimensions. */
  nc.def_dim(vertex_dim_name, mesh.nV()); nc.err();
  nc.def_dim(triangle_dim_name, mesh.nT()); nc.err();
  nc.def_dim(index_dim_name, 3); nc.err();

  /* Define coordinate netCDF variables. They will hold the
     index information. A
     varid is returned for each.*/
  nc.def_var(vertex_dim_name, NC_INT, vertex_dim_name); nc.err();
  nc.def_var(triangle_dim_name, NC_INT, triangle_dim_name); nc.err();
  nc.def_var(index_dim_name, NC_INT, index_dim_name); nc.err();

  nc.put_att_text(vertex_dim_name, "units", vertex_dim_name).err();
  nc.put_att_text(triangle_dim_name, "units", triangle_dim_name).err();
  nc.put_att_text(index_dim_name, "units", index_dim_name).err();

  /* Define the netCDF variables. The dimids array is used to pass
     the dimids of the dimensions of the variables.*/
  std::vector<std::string> dim_ids(2);
  dim_ids[0] = vertex_dim_name;
  dim_ids[1] = index_dim_name;
  nc.def_var(vertex_name, NC_DOUBLE, dim_ids); nc.err();
  dim_ids[0] = triangle_dim_name;
  dim_ids[1] = index_dim_name;
  nc.def_var(triangle_name, NC_INT, dim_ids); nc.err();

  /* Define units attributes for vars. */
  nc.put_att_text(vertex_name, "units", vertex_units).err();
  nc.put_att_text(triangle_name, "units", triangle_units).err();
  nc.put_att_text(vertex_name, "long_name", vertex_long_name).err();
  nc.put_att_text(triangle_name, "long_name", triangle_long_name).err();

  /* End define mode. */
  nc.enddef().err();

  /* Write the dimension variable data.*/
  std::vector<int> dim_var(mesh.nV());
  for (int64_t i = 0; i < (int64_t)mesh.nV(); ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(vertex_dim_name, dim_var.data()).err();
  dim_var.resize(mesh.nT());
  for (int64_t i = 0; i < (int64_t)mesh.nT(); ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(triangle_dim_name, dim_var.data()).err();
  dim_var.resize(3);
  for (int64_t i = 0; i < 3; ++i) {
    dim_var[i] = i;
  }
  nc.iput_var<int>(index_dim_name, dim_var.data()).err();
 
  nc.iput_var<double>(vertex_name, mesh.S().raw()).err();
  nc.iput_var<int>(triangle_name, mesh.TV().raw()).err();

  LOG_("before waiting" << std::endl);
  nc.wait_all().stat();
  LOG_("after waiting" << std::endl);

  /* Close the file. */
  nc.close().err();
  LOG_("closed" << std::endl);
 }







void MeshBilevel::import_python(const std::string& fileroot) {
  clear_meshes();
  // Read meshes from python generated netcdf files
  timer_tic("Initialising meshes");
  timer_tic("Mesh level " + to_string(levels_[0]));
  initialise_mesh_from_python(meshes_[0], levels_[0], fileroot);
  timer_toc_tic("Mesh level " + to_string(levels_[1]));
  fmesh::Mesh mesh_tmp;
  initialise_mesh_from_python(mesh_tmp, levels_[1], fileroot);
  timer_toc();
  
  timer_toc_tic("Reorganise and create mappings");
  reorganise_from_python(mesh_tmp);
  timer_toc();
  initialised_meshes_ = true;

  macro_domain_root_vertex_ = -1;
  initialise_macro_domain_root_set();

  // Generate locator information
  initialise_locators();
  timer_toc();
}


void MeshBilevel::import_direct(const std::string& fileroot) {
  clear_meshes();
  // Read meshes from self-generated netcdf files
  timer_tic("Initialising meshes");
  LOG("NOT IMPLEMENTED");
  //    initialise_meshes_direct(meshes_, levels_, fileroot, timer_);

  timer_tic("Mesh level " + to_string(levels_[0]));
  //  initialise_mesh_from_netcdf(meshes_[0], levels_[0], fileroot);
  
  timer_toc_tic("Mesh level " + to_string(levels_[1]));
  //  initialise_mesh_from_netcdf(meshes_[1], levels_[1], fileroot);
  timer_toc();
  
  initialised_meshes_ = true;

  // Setup domain roots
  macro_domain_root_vertex_ = -1;
  initialise_macro_domain_root_set();

  // Generate locator information
  initialise_locators();
  timer_toc();
}


void MeshBilevel::export_direct(const std::string& fileroot) {
  // Read meshes from self-generated netcdf files
  timer_tic("Exporting meshes");

  timer_tic("Mesh level " + to_string(levels_[0]));
  std::string filename(fileroot + "_macro" + to_string(levels_[0]) + ".nc");
  export_mesh_to_netcdf(meshes_[0], filename);
  
  timer_toc_tic("Mesh level " + to_string(levels_[1]));
  filename = std::string(fileroot + "_micro" + to_string(levels_[1]) + ".nc");
  export_mesh_to_netcdf(meshes_[1], filename);
  timer_toc();

  timer_toc();
}



void MeshBilevel::reorganise_from_python(const fmesh::Mesh& mesh_py) {
  timer_tic("Reorganise from Python to C");

  timer_toc_tic("Construct triangle remapping info for macro mesh");
  initialise_python_index();
  python_index_->num_basis(meshes_[0].nV(), meshes_[1].nV());
  IndexMap::IteratorPair iterAB_tri = python_index_->triangle_macro().ABend();
  for (int64_t tri = 0; tri < (int64_t)meshes_[0].nT(); ++tri) {
    iterAB_tri = python_index_->triangle_macro().insert(iterAB_tri, triangle_index_swapwise(tri, levels_[0]), tri);
  }
  timer_toc();
  
  timer_tic("Find new vertex order");
  
  /* Keep macro nodes in place */
  macro_vertex_begin_.resize(meshes_[0].nV());
  IndexMap::IteratorPair iterAB = python_index_->vertex().ABbegin();
  for (uint64_t i=0; i < meshes_[0].nV(); ++i) {
    iterAB = python_index_->vertex().insert(iterAB, i, i);
    macro_vertex_begin_(i) = i;
  }
  uint64_t next_self_index = meshes_[0].nV();
  
  LOG("vertex_index" << std::endl << python_index_->vertex() << std::endl);
  LOG("triangle_index0" << std::endl << python_index_->triangle_macro() << std::endl);

  /* Handle macro edges */
  macro_boundary_.setConstant(meshes_[0].nT(), 3, false);
  supermesh_macro_boundary_.setConstant(meshes_[0].nT(), 3, false);
  macro_edge_begin_.setConstant(meshes_[0].nT(), 3, -1);
  if (macro_edge_size_ > 0) {
    for (uint64_t tri=0; tri < meshes_[0].nT(); ++tri) {
      //    int64_t triB0 = python_index_->triangle_macro().AtoB(tri);
      int64_t triB0 = tri; // Macro mesh triangles are already in correct order.
      fmesh::Dart dh_B0 = fmesh::Dart(meshes_[0], triB0, 1, 0);
      fmesh::Dart dh_py = fmesh::Dart(mesh_py, get_micro_triangle_index(tri, levels_[0], levels_[1]), 1, 0);
      for (uint64_t sub_vertex=0; sub_vertex < 3; ++sub_vertex) {
        bool is_boundary = dh_py.onBoundary();
        assert(!is_boundary || (is_boundary && dh_B0.onBoundary()));
        macro_boundary_(tri, (sub_vertex+2)%3) = is_boundary;
        supermesh_macro_boundary_(tri, (sub_vertex+2)%3) = is_boundary;
        bool handle_edge = triangle_is_edge_owner(dh_B0);
        bool handle_backwards = handle_edge & (dh_B0.v() > dh_B0.vo());
        if (handle_edge) {
          macro_edge_begin_(tri, (sub_vertex+2)%3) = next_self_index;
        } else {
          macro_edge_begin_(tri, (sub_vertex+2)%3) = -1;
        }
        for (int64_t along=0; along < macro_edge_size_ ; ++along) {
          dh_py.orbit2().orbit0rev().orbit0rev();
          if (handle_edge) {
            if (handle_backwards) {
              iterAB = python_index_->vertex().insert(iterAB, dh_py.v(), next_self_index + macro_edge_size_ - 1 - along);
            } else {
              iterAB = python_index_->vertex().insert(iterAB, dh_py.v(), next_self_index + along);
            }
          }
        }
        if (handle_edge) {
          next_self_index += macro_edge_size_;
        }
        // Move to the first point of the next edge
        dh_py.orbit2();
        dh_B0.orbit2();
      }
    }
  }

  LOG("vertex_index" << std::endl << python_index_->vertex() << std::endl);
  LOG("macro_boundary" << std::endl << macro_boundary_ << std::endl);
  LOG("macro_edge_begin" << std::endl << macro_edge_begin_ << std::endl);

  if (macro_edge_size_ > 0) {
    /* Copy info for non-owned edges */
    for (uint64_t tri=0; tri < meshes_[0].nT(); ++tri) {
      for (uint64_t sub_vertex=0; sub_vertex < 3; ++sub_vertex) {
        if (macro_edge_begin_(tri, sub_vertex) == -1) {
          // Get Dart for opposing edge, so that tadj is the neighbouring triangle.
          fmesh::Dart d = macro_opposing_edge(tri, sub_vertex);
          // Use the TTi information to locate the edge index information
          macro_edge_begin_(tri, sub_vertex) = macro_edge_begin_(d.tadj(), meshes_[0].TTi(tri)[sub_vertex]);
        }
      }
    }
  }

  LOG("macro_edge_begin" << std::endl << macro_edge_begin_ << std::endl);


  /* Keep macro triangle interiors */
  macro_interior_begin_.setConstant(meshes_[0].nT(), 1, -1);
  if (macro_interior_size_ > 0) {
    /* Number of interior point layers inside a macro triangle */
    int64_t triangle_layers = macro_edge_size_ - 1;
    for (uint64_t tri=0; tri < meshes_[0].nT(); ++tri) {
      macro_interior_begin_(tri) = next_self_index;
      fmesh::Dart d0 = fmesh::Dart(mesh_py, get_micro_triangle_index(tri, levels_[0], levels_[1]));
      // For each interior point layer:
      for (int64_t layer=0; layer < triangle_layers ; ++layer) {
        // Move to next point along the 0-2 edge, point towards first interior point.
        d0.orbit2rev().orbit0().orbit0();
        fmesh::Dart d = d0;
        for (int64_t along=0; layer + along < triangle_layers ; ++along) {
          d.orbit2().orbit0rev().orbit0rev();
          iterAB = python_index_->vertex().insert(iterAB, d.v(), next_self_index);
          ++next_self_index;
        }
      }
    }
  }
  timer_toc(); // Find new order

  timer_tic("Construct S for the new mesh");
  fmesh::Matrix3double S_input;
  for (uint64_t orig_idx = 0; orig_idx < mesh_py.nV(); ++orig_idx) {
    S_input(python_index_->vertex().AtoB(orig_idx)) = mesh_py.S(orig_idx);
  }
  timer_toc_tic("Construct TV for the new mesh");
  iterAB_tri = python_index_->triangle_micro().ABbegin();
  fmesh::Matrix3int TV_input;
  for (uint64_t tri = 0; tri < mesh_py.nT(); ++tri) {
    iterAB_tri = python_index_->triangle_micro().insert(iterAB_tri, triangle_index_swapwise(tri, levels_[1]), tri);
    TV_input(tri)[0] = python_index_->vertex().AtoB(mesh_py.TV(tri)[0]);
    TV_input(tri)[1] = python_index_->vertex().AtoB(mesh_py.TV(tri)[1]);
    TV_input(tri)[2] = python_index_->vertex().AtoB(mesh_py.TV(tri)[2]);
  }
  timer_toc_tic("Set micro S and TV");
  meshes_[1].clear();
  meshes_[1].type(meshes_[0].type());
  meshes_[1].S_set(S_input);
  meshes_[1].TV_set(TV_input);
  timer_toc();
  
  timer_toc(); // Reorganise
}



void MeshBilevel::copy_python_index_to_submesh(MeshBilevel& super_mesh) {
  timer_tic("Copy python indices for submesh");
  initialise_python_index();
  python_index_->num_basis(super_mesh.macro_num_basis(),
                           super_mesh.micro_num_basis());
  IndexMap::IteratorPair index_hint = python_index_->vertex().ABend();
  for (IndexMap::IteratorA iter = supermesh_index_->vertex().Abegin();
       iter != supermesh_index_->vertex().Aend();
       ++iter) {
    index_hint = python_index_->vertex().insert(index_hint,
                                                super_mesh.python_index_->vertex().BtoA(iter->first),
                                                iter->second);
  }
  index_hint = python_index_->triangle_macro().ABend();
  for (IndexMap::IteratorA iter = supermesh_index_->triangle_macro().Abegin();
       iter != supermesh_index_->triangle_macro().Aend();
       ++iter) {
    index_hint = python_index_->triangle_macro().insert(index_hint,
                                                        super_mesh.python_index_->triangle_macro().BtoA(iter->first),
                                                        iter->second);
  }
  index_hint = python_index_->triangle_micro().ABend();
  for (IndexMap::IteratorA iter = supermesh_index_->triangle_micro().Abegin();
       iter != supermesh_index_->triangle_micro().Aend();
       ++iter) {
      index_hint = python_index_->triangle_micro().insert(index_hint,
                                                          super_mesh.python_index_->triangle_micro().BtoA(iter->first),
                                                          iter->second);
  }
  timer_toc();
}








/** Find macro triangles connected to macro vertices */
std::set<int64_t> MeshBilevel::find_mesh_subset(std::set<int64_t>& macro_vertices) {
  std::set<int64_t> triangles;
  triangles.clear();

  /* Find the macro triangles connected to the macro vertices. */
  timer_tic("Find macro triangles");
  for (std::set<int64_t>::iterator iter = macro_vertices.begin();
       iter != macro_vertices.end();
       ++iter) {
    fmesh::Dart dh;
    fmesh::Dart dh0;
    /* Find starting edge on boundary if there is one */
    dh0 = meshes_[0].locate_vertex(fmesh::Dart(), *iter);
    if (!dh0.onBoundary()) {
      dh = dh0;
      dh.orbit0rev();
      while (!dh.onBoundary() & (dh != dh0)) {
        dh.orbit0rev();
      }
      dh0 = dh;
    }

    // Go through the macro triangles around the vertex and add them to the triangle set */
    dh = dh0;
    bool first = true;
    while (first | (!dh.onBoundary() & (dh != dh0))) {
      first = false;
      triangles.insert(dh.t());
      dh.orbit2(); // Now on opposing edge
      LOG("dh = " << dh << std::endl);
      dh.orbit2();
      if (!dh.onBoundary()) {
        dh.orbit1();
      }
    }
  }
  timer_toc();
  return triangles;
}

void MeshBilevel::define_subset_from_vertices(MeshBilevel& super_mesh,
                                              std::set<int64_t>& super_macro_vertices,
                                              bool claim_boundary) {
  assert(super_macro_vertices.size() >= 1);

    // Translate super macro vertex indices.
  std::set<int64_t> triangles = super_mesh.find_mesh_subset(super_macro_vertices);
  define_subset_from_triangles(super_mesh, triangles, claim_boundary);

  // Lookup the root vertex.
  if (super_macro_vertices.size() > 1) {
    macro_domain_root_vertex_ = -1;
  } else {
    macro_domain_root_vertex_ = supermesh_index_->vertex().AtoB(*super_macro_vertices.begin());
  }

  timer_tic("Initialise weights");
  initialise_weights();
  timer_toc();
}

/** Define a submesh covering macro triangles of a supermesh.
 *
 */
void MeshBilevel::define_subset_from_triangles(MeshBilevel& super_mesh,
                                               std::set<int64_t>& super_macro_triangles,
                                               bool claim_boundary)
{

  LOG_(std::endl);

  clear_meshes();
  initialise_supermesh_index();
  supermesh_index_->num_basis(super_mesh.macro_num_basis(),
                              super_mesh.micro_num_basis());
  set_levels(super_mesh.levels_[0], super_mesh.levels_[1]);
  macro_edge_size_ = super_mesh.macro_edge_size_;
  macro_interior_size_ = super_mesh.macro_interior_size_;

  timer_tic("Define submesh");
  timer_tic("Define macro submesh");

    LOG_(std::endl);

  timer_tic("Map macro triangles and vertices");
  // Go through the macro triangles to build vertex-vertex and triangle-triangle index mapping
  int64_t next_vertex = 0;
  int64_t next_triangle = 0;
  IndexMap::IteratorPair vertex_index_hint = supermesh_index_->vertex().ABend();
  IndexMap::IteratorPair triangle_index_hint = supermesh_index_->triangle_macro().ABend();
  for (std::set<int64_t>::iterator tri_iter = super_macro_triangles.begin();
       tri_iter != super_macro_triangles.end();
       ++tri_iter) {
    triangle_index_hint = supermesh_index_->triangle_macro().insert(triangle_index_hint, *tri_iter, next_triangle++);
    for (int64_t vtx = 0; vtx < 3; ++vtx) {
      int64_t the_vtx = super_mesh.meshes_[0].TV(*tri_iter)[vtx];
      if (supermesh_index_->vertex().AtoB_iter(the_vtx) == supermesh_index_->vertex().AtoB().end()) {
        vertex_index_hint = supermesh_index_->vertex().insert(vertex_index_hint, the_vtx, next_vertex++);
      }
    }
  }
  
  LOG("vertex_index" << std::endl << supermesh_index_->vertex());
  LOG("triangle_index0" << std::endl << supermesh_index_->triangle_macro());

    LOG_(std::endl);

  timer_toc_tic("Build macro S and TV");
  fmesh::Matrix3double S_input;
  fmesh::Matrix3int TV_input;
  S_input.rows(supermesh_index_->vertex().BtoA().size());
  TV_input.rows(supermesh_index_->triangle_macro().BtoA().size());
  for (IndexMap::IteratorB vtx_iter = supermesh_index_->vertex().Bbegin();
       vtx_iter != supermesh_index_->vertex().Bend();
       ++vtx_iter) {
    int64_t vtxB = vtx_iter->first;
    int64_t vtxA = vtx_iter->second;
    S_input(vtxB)[0] = super_mesh.meshes_[0].S(vtxA)[0];
    S_input(vtxB)[1] = super_mesh.meshes_[0].S(vtxA)[1];
    S_input(vtxB)[2] = super_mesh.meshes_[0].S(vtxA)[2];
  }
  LOG_(std::endl);
  for (IndexMap::IteratorB tri_iter=supermesh_index_->triangle_macro().Bbegin();
       tri_iter != supermesh_index_->triangle_macro().Bend();
       ++tri_iter) {
    int64_t triB = tri_iter->first;
    int64_t triA = tri_iter->second;
    TV_input(triB)[0] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[0].TV(triA)[0]);
    TV_input(triB)[1] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[0].TV(triA)[1]);
    TV_input(triB)[2] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[0].TV(triA)[2]);
  }

  LOG("vertex_index" << std::endl << supermesh_index_->vertex());

    LOG_(std::endl);

  timer_toc_tic("Set macro S and TV");
  meshes_[0].clear();
  meshes_[0].type(super_mesh.meshes_[0].type());
  meshes_[0].S_set(S_input);
  meshes_[0].TV_set(TV_input);
  timer_toc();

    LOG_(std::endl);

  timer_tic("Setup boundary information");
  macro_boundary_.setConstant(next_triangle, 3, false);
  supermesh_macro_boundary_.setConstant(next_triangle, 3, false);
  for (int64_t tri=0; tri < next_triangle; ++tri) {
    int64_t triA = supermesh_index_->triangle_macro().BtoA(tri);
    fmesh::Dart dh = macro_opposing_edge(tri, 0);
    for (int64_t vtx = 0; vtx < 3; ++vtx) {
      macro_boundary_.row(tri)[vtx] = dh.onBoundary();
      if (claim_boundary) {
        supermesh_macro_boundary_.row(tri)[vtx] = dh.onBoundary();
      }
      dh.orbit2();
    }
    if (!claim_boundary) {
      supermesh_macro_boundary_.row(tri) = super_mesh.supermesh_macro_boundary_.row(triA);
    }
  }
  timer_toc();

    LOG_(std::endl);

  LOG("vertex_index" << std::endl << supermesh_index_->vertex());

  timer_toc(); // Define macro submesh
  timer_tic("Define micro submesh");

  timer_tic("Map vertex indices");
  macro_vertex_begin_.resize(next_vertex, 1);
  for (int64_t vtx=0; vtx < next_vertex; ++vtx) {
    macro_vertex_begin_(vtx) = vtx;
  }

  LOG_(std::endl);

  timer_toc_tic("Map edge vertex indices");
  LOG("macro_edge_size_ = " << macro_edge_size_ << std::endl);

  LOG("super_mesh.macro_edge_begin" << std::endl << super_mesh.macro_edge_begin_ << std::endl);
  
  macro_edge_begin_.setConstant(next_triangle, 3, -1);
  if (macro_edge_size_ > 0) {
    for (int64_t tri=0; tri < next_triangle; ++tri) {
      int64_t triA = supermesh_index_->triangle_macro().BtoA(tri);
      for (uint64_t vtx=0; vtx < 3; ++vtx) {
        fmesh::Dart dh = macro_opposing_edge(tri, vtx);
        if (triangle_is_edge_owner(dh)) {
          macro_edge_begin_(tri, vtx) = next_vertex;
          LOG("macro_edge_begin(tri=" << tri << ", vtx=" << vtx << ") = " << macro_edge_begin_(tri, vtx) << std::endl);
          for (int64_t edge_vtx=0; edge_vtx < macro_edge_size_; ++edge_vtx) {
            LOG("edge0 = " << super_mesh.meshes_[0].TV(triA)[(vtx + 1) % 3] << ", "
                << super_mesh.meshes_[0].TV(triA)[(vtx + 2) % 3] << std::endl);
            LOG("vtxA(" << triA << "," << vtx << ") = "
                << super_mesh.macro_edge_begin_(triA, vtx) << " + " << edge_vtx
                << " = " << super_mesh.macro_edge_begin_(triA, vtx) + edge_vtx
                << ", vtxB = " << next_vertex << std::endl);
            vertex_index_hint =
                supermesh_index_->vertex().insert(vertex_index_hint,
                                                  super_mesh.macro_edge_begin_(triA, vtx) + edge_vtx,
                                                  next_vertex++);
          }
        }
      }
    }
  }

    LOG_(std::endl);

  LOG("vertex_index" << std::endl << supermesh_index_->vertex());
  LOG("triangle_index" << std::endl << supermesh_index_->triangle_macro());

  if (macro_edge_size_ > 0) {
    /* Copy info for non-owned edges */
    for (int64_t tri=0; tri < next_triangle; ++tri) {
      // int64_t triA = supermesh_index_->triangle_macro().BtoA(tri); // Not used
      for (uint64_t vtx=0; vtx < 3; ++vtx) {
        if (macro_edge_begin_(tri, vtx) == -1) {
          fmesh::Dart d = macro_opposing_edge(tri, vtx);
          // Use the TTi information to locate the edge index information
          macro_edge_begin_(tri, vtx) = macro_edge_begin_(d.tadj(), meshes_[0].TTi(tri)[vtx]);
        }
      }
    }
  }

  LOG("macro_edge_begin" << std::endl << macro_edge_begin_);

    LOG_(std::endl);

  timer_toc_tic("Map interior vertex indices");
  LOG("macro_interior_size_ = " << macro_interior_size_ << std::endl);
  macro_interior_begin_.setConstant(next_triangle, 1, -1);
  if (macro_interior_size_ > 0) {
    for (int64_t triB=0; triB < (int64_t)meshes_[0].nT(); ++triB) {
      int64_t triA = supermesh_index_->triangle_macro().BtoA(triB);
      macro_interior_begin_(triB) = next_vertex;
      for (int64_t interior_vtx=0; interior_vtx < macro_interior_size_; ++interior_vtx) {
        vertex_index_hint =
            supermesh_index_->vertex().insert(vertex_index_hint,
                                              super_mesh.macro_interior_begin_(triA) + interior_vtx,
                                              next_vertex++);
      }
    }
  }
  timer_toc();

  LOG("vertex_index" << std::endl << supermesh_index_->vertex());
  LOG("triangle_index0" << std::endl << supermesh_index_->triangle_macro());

    LOG_(std::endl);

  timer_tic("Map micro triangle indices");
  triangle_index_hint = supermesh_index_->triangle_micro().ABend();
  for (IndexMap::IteratorA macro_triA_iter=supermesh_index_->triangle_macro().Abegin();
       macro_triA_iter != supermesh_index_->triangle_macro().Aend();
       ++macro_triA_iter) {
    int64_t triA = get_micro_triangle_index(macro_triA_iter->first, levels_[0], levels_[1]);
    int64_t triB = get_micro_triangle_index(macro_triA_iter->second, levels_[0], levels_[1]);
    int64_t triA_end = get_micro_triangle_index(macro_triA_iter->first+1, levels_[0], levels_[1]);
    while (triA < triA_end) {
      triangle_index_hint = supermesh_index_->triangle_micro().insert(triangle_index_hint, triA, triB);
      ++triA;
      ++triB;
    }
  }
  timer_toc();

  LOG_(std::endl);

  LOG("triangle_index1" << std::endl << supermesh_index_->triangle_micro());

  timer_tic("Build micro S and TV");
  S_input.rows(supermesh_index_->vertex().BtoA().size());
  TV_input.rows(supermesh_index_->triangle_micro().BtoA().size());
  for (IndexMap::IteratorB vtx_iter=supermesh_index_->vertex().Bbegin();
       vtx_iter != supermesh_index_->vertex().Bend();
       ++vtx_iter) {
    int64_t vtxB = vtx_iter->first;
    int64_t vtxA = vtx_iter->second;
    S_input(vtxB)[0] = super_mesh.meshes_[1].S(vtxA)[0];
    S_input(vtxB)[1] = super_mesh.meshes_[1].S(vtxA)[1];
    S_input(vtxB)[2] = super_mesh.meshes_[1].S(vtxA)[2];
  }
  LOG("vertex_index" << std::endl << supermesh_index_->vertex());
  LOG("triangle_index0" << std::endl << supermesh_index_->triangle_macro());
  LOG("triangle_index1" << std::endl << supermesh_index_->triangle_micro());

    LOG_(std::endl);

  for (IndexMap::IteratorB tri_iter=supermesh_index_->triangle_micro().Bbegin();
       tri_iter != supermesh_index_->triangle_micro().Bend();
       ++tri_iter) {
    int64_t triB = tri_iter->first;
    int64_t triA = tri_iter->second;
    LOG("tri A -> B = " << triA << " -> " << triB << std::endl);
    LOG("TVA(" << triA << ") = ("
	      << super_mesh.meshes_[1].TV(triA)[0] << ", "
	      << super_mesh.meshes_[1].TV(triA)[1] << ", "
	      << super_mesh.meshes_[1].TV(triA)[2] << ")\n");
    LOG("TVB(" << triB << ") = ("
	<< supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[0]) << ", "
	<< supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[1]) << ", "
	<< supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[2]) << ")\n");
    TV_input(triB)[0] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[0]);
    TV_input(triB)[1] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[1]);
    TV_input(triB)[2] = supermesh_index_->vertex().AtoB(super_mesh.meshes_[1].TV(triA)[2]);
  }
  LOG("vertex_index" << std::endl << supermesh_index_->vertex());
  LOG("triangle_index0" << std::endl << supermesh_index_->triangle_macro());
  LOG("triangle_index1" << std::endl << supermesh_index_->triangle_micro());

  LOG_(std::endl);

  copy_python_index_to_submesh(super_mesh);

  timer_toc_tic("Set micro S and TV");
  meshes_[1].clear();
  meshes_[1].type(meshes_[0].type());
  meshes_[1].S_set(S_input);
  meshes_[1].TV_set(TV_input);
  timer_toc();

  timer_toc(); // Define micro submesh

  initialised_meshes_ = true;
  LOG_(std::endl);

  macro_domain_root_vertex_ = -1;
  if (claim_boundary) {
    initialise_macro_domain_root_set();
  } else {
    initialise_macro_domain_root_set(super_mesh);
  }

  // Generate locator information
  initialise_locators();
  timer_toc();
}




void MeshBilevel::initialise_macro_domain_root_set() {
  timer_tic("Construct macro domain root vertex information");
  macro_domain_root_set_.clear();
  // Scan all triangles.
  // Any vertex attached to more than two triangles must be a domain root.
  // Each non-boundary edge must have at least one domain root.
  // Each (all-boundary) triangle must have at least one domain root.
  for (int64_t tri = 0; tri < (int64_t)meshes_[0].nT(); ++tri) {
    fmesh::Dart dh0(meshes_[0], tri, 1, 0);
    for (int v = 0; v < 3; ++v) {
      if (in_macro_domain_root_set(dh0.v())) {
        // Already marked as root node, skip.
        continue;
      }
      fmesh::Dart dh = dh0;
      if (!dh.onBoundary()) {
        dh.orbit0rev();
        while (!dh.onBoundary() && (dh != dh0)) {
          dh.orbit0rev();
        }
      }
      // dh is either on boundary, or the vertex is a non-boundary vertex (and dh == dh0)
      if (!dh.onBoundary()) {
        // Inner vertex, must have more than two triangles: must be a root node.
        macro_domain_root_set_.insert(dh0.v());
      } else {
        // Boundary vertex.
        int counter = 1;
        dh.orbit2rev(); // Go to next CCW radial edge, still in the same triangle
        while (!dh.onBoundary()) {
          dh.orbit1(); // Rotate the edge into the next triangle.
          ++counter;
          dh.orbit2rev();
        }
        // counter == the number of triangles attached to the vertex
        if (counter > 2) {
          macro_domain_root_set_.insert(dh0.v());
        }
      }
      dh0.orbit2();
    }
    // Check non-boundary edges to make sure at least one root per edge.
    for (int v = 0; v < 3; ++v) {
      if (!dh0.onBoundary() &&
          !in_macro_domain_root_set(dh0.v()) &&
          !in_macro_domain_root_set(dh0.vo())) {
        // Force a root node
        macro_domain_root_set_.insert(dh0.v());
      }
      dh0.orbit2();
    }
    // Check all edges to make sure at least one root per triangle.
    bool any_root = in_macro_domain_root_set(dh0.v()) || in_macro_domain_root_set(dh0.vo());
    dh0.orbit2rev();
    any_root = any_root || in_macro_domain_root_set(dh0.v());
    if (!any_root) {
      // Force a root node
      macro_domain_root_set_.insert(dh0.vo());
    }
  }
  timer_toc();
}


void MeshBilevel::initialise_macro_domain_root_set(MeshBilevel& super_mesh) {
  timer_tic("Copy macro domain root vertex information");
  assert(supermesh_index_ != NULL);
  macro_domain_root_set_.clear();
  for (uint64_t vertex = 0; vertex < meshes_[0].nV(); ++vertex) {
    if (super_mesh.in_macro_domain_root_set(supermesh_index_->vertex().BtoA(vertex))) {
      macro_domain_root_set_.insert(vertex);
    }
  }
  timer_toc();
}
















//  std::vector<fmesh::TriangleLocator* > locators_;
//  bool initialised_meshes_;
//
//  IndexMap vertex_index_;
//  IndexMap triangle_index1_;
//
//  /** TRUE if the macro edge belongs to the triangle, in terms of storage responsibility.
//   * The column index refers to opposing edge (edge 0 is the 1-2 edge, 1 is the 2-0 edge, 2 is the 0-1 edge. */
//  Eigen::Matrix<bool, Eigen::Dynamic, 3> macro_edge_owner_;
//  /** Index of the first macro edge vertex for each edge of a macro triangle */
//  Eigen::Matrix<int64_t, Eigen::Dynamic, 3> macro_edge_begin_;
//  /** Index of the first interior vertex of each macro triangle */
//  Eigen::Matrix<int64_t, Eigen::Dynamic, 1> macro_interior_begin_;




































TimeMeshUnitless::TimeMeshUnitless(double domain_begin,
                                   double domain_end,
                                   int64_t num_intervals,
                                   TimeBasis basis,
                                   bool is_cyclic) :
    domain_begin_(domain_begin),
    domain_end_(domain_end),
    step_size_(0.0),
    num_intervals_(0),
    num_basis_(0),
    basis_(basis),
    is_cyclic_(is_cyclic),
    super_mesh_(NULL),
    super_mesh_info_()
{
  assert(domain_begin < domain_end);
  if (basis == TimeBasis::Bspline2) {
    assert(num_intervals >= 1);
    num_intervals_ = num_intervals;
    num_basis_ = num_intervals + 2 * (!is_cyclic);
    step_size_ = (domain_end - domain_begin) / double(num_intervals);
  } else if (basis == TimeBasis::Harmonic) {
    assert(num_intervals >= 0);
    num_intervals_ = 1;
    num_basis_ = 1 + num_intervals * 2;
    step_size_ = domain_end_ - domain_begin_;
  } else {
    assert(false);
  }
}

TimeMeshUnitless::TimeMeshUnitless(TimeMeshUnitless* the_super_mesh,
                                   const SuperMeshInfo& info,
                                   int64_t extra_shift) :
    domain_begin_(the_super_mesh->domain_begin() +
                  the_super_mesh->step_size() * info.shift_size() * (info.shift() + extra_shift)),
    domain_end_(the_super_mesh->domain_begin() +
                the_super_mesh->step_size() * info.shift_size() * (info.shift() + extra_shift) +
                the_super_mesh->step_size() * info.subdomain_intervals()),
    step_size_(the_super_mesh->step_size()),
    num_intervals_(info.subdomain_intervals()),
    num_basis_(0),
    basis_(the_super_mesh->get_basis()),
    is_cyclic_(the_super_mesh->is_cyclic()),
    super_mesh_(the_super_mesh),
    super_mesh_info_(info.subdomain_intervals(),
                     info.shift_size(),
                     info.shift() + extra_shift)
{
  assert(!is_cyclic_); // Cyclic models not supported yet
  assert(domain_begin_ < domain_end_);
  if (basis_ == TimeBasis::Bspline2) {
    assert(num_intervals_ >= 1);
    num_basis_ = num_intervals_ + 2;
    if (super_mesh_info_.offset() + num_basis_ > the_super_mesh->num_basis()) {
      LOG_("Imperfect subdomain match; subdomain extends beyond supermesh" << std::endl);
    }
  } else if (basis_ == TimeBasis::Harmonic) {
    assert(false);
  } else {
    assert(false);
  }
}

void TimeMeshUnitless::eval(double the_time, TimeMeshUnitless::eval_type& output) {
  if ((the_time < domain_begin_) | (the_time > domain_end_)) {
    output.resize(0);
    return;
  }
  if (num_basis_ == 1) {
    output.resize(1);
    output[0].first = 0;
    output[0].second = 1.0;
    return;
  }
  if (basis_ == TimeBasis::Bspline2) {
    // B-splines
    int64_t idx = index(the_time);
    double local_time = (the_time - domain_begin_ - idx * step_size_) / step_size_;
    output.resize(3);
    if (is_cyclic_) {
      output[0].first = (idx + num_basis_ - 1) % num_basis_;
      output[1].first = idx;
      output[2].first = (idx + 1) % num_basis_;
    } else {
      output[0].first = idx;
      output[1].first = idx + 1;
      output[2].first = idx + 2;
    }
    output[0].second = (1.0 - local_time) * (1.0 - local_time) / 2.0;
    output[2].second = local_time * local_time / 2.0;
    output[1].second = 1.0 - output[0].second - output[2].second;
  } else {
    // Harmonic
    double local_time = (the_time - domain_begin_) / step_size_;
    local_time = local_time - std::floor(local_time);
    if (is_cyclic_) {
      local_time *= 2.0 * M_PI;
    } else {
      local_time *= M_PI;
    }
    output.resize(num_basis_);
    output[0].first = 0;
    output[0].second = 1.0;
    for (int i = 1; i < num_basis_; ++i) {
      double order = double((i - 1) / 2);
      output[i].first = i;
      if (i % 2 == 1) {
        output[i].second = std::cos(local_time * order);
      } else {
        output[i].second = std::sin(local_time * order);
      }
    }
  }
}


/**
 * 1   1 1/2 0 0
 *
 * 1  4  6 4 1
 *
 * \f{align*}{b0^4 + 4 b0^3 b1 + b0^2 6 b1^2 /2
 *  \\&= b0^2 (b0^2 + 4 b0 (1-b0) + 3 (1-b0)^2)
 *  \\&= b0^2 (b0^2 + 4 b0 - 4 b0^2 + 3 - 6 b0 + 3 b0^2)
 *  \\&= b0^2 (3 - 2 b0)
 * \f}
 */
void TimeMeshUnitless::get_weights(
    int64_t halo_depth,
    Eigen::Matrix<double, Eigen::Dynamic, 1>& halo_hat,
    Eigen::Matrix<double, Eigen::Dynamic, 1>& weights)
{
  if (super_mesh_ == NULL || (num_basis_ <= 1)) {
    halo_hat = Eigen::Matrix<double, Eigen::Dynamic, 1>::Ones(num_basis_);
    weights = Eigen::Matrix<double, Eigen::Dynamic, 1>::Ones(num_basis_);
    return;
  }
  if (num_basis_ <= 2 * (halo_depth+1)) {
    LOG_("Warning, halo covers everything:" << std::endl
         << "\tnum_basis = " << num_basis_ << " <= "
         << "2 * (halo_depth + 1) = " << 2 * (halo_depth + 1) << std::endl);
  }
  if (num_basis_ - super_mesh_info_.shift_size() < 2 * halo_depth + 1) {
    LOG_("Warning, insufficient overlap:" << std::endl
         << "\tnum_basis_ - super_mesh_info_.shift_size() = "
         << num_basis_ - super_mesh_info_.shift_size() << " < "
         << "2 * halo_depth + 1 = " << 2 * halo_depth + 1 << std::endl);
  }
  double rel_halo_depth = double(halo_depth) / (double(num_basis_ - 1) / 2.0);

  // How many neighbouring meshes overlap on each side?
  int64_t num_extra = num_basis_ / super_mesh_info_.shift_size() - 1;
  
  // Distance from end point basis functions, normalised so 1.0 is in the middle
  Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> dist;
  dist.resize(num_basis_, 1 + 2 * num_extra);
  for (int64_t k = 0; k < num_basis_; ++k) {
    dist(k, 0) = std::max(0.0,
                          1.0 - std::fabs(double(2 * k)
                                          / double(num_basis_ - 1)
                                          - 1.0));
    for (int64_t extra = 1; extra <= num_extra; ++extra) {
      // Left:
      dist(k, 2*extra - 1) =
          std::max(0.0,
                   1.0 - std::fabs(double(2 * (k + extra * super_mesh_info_.shift_size())) /
                                   double(num_basis_ - 1)
                                   - 1.0));
      // Right:
      dist(k, 2*extra) =
          std::max(0.0,
                   1.0 - std::fabs(double(2 * (k - extra * super_mesh_info_.shift_size())) /
                                   double(num_basis_ - 1)
                                   - 1.0));
    }
  }
  // Compute weights
  Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> weights_all;
  weights_all.resize(num_basis_, 1 + 2 * num_extra);
  weights_all = dist.array() * dist.array() * (3.0 - 2.0 * dist.array());
  weights = (weights_all.col(0).array() / weights_all.rowwise().sum().array()).sqrt();
      
  // Convert distances to halo_hat
  for (int64_t k = 0; k < num_basis_; ++k) {
    for (int64_t j = 0; j < 1 + 2 * num_extra; ++j) {
      dist(k, j) = std::max(0.0, dist(k, j) - rel_halo_depth);
    }
  }
  halo_hat = dist.col(0).array() / dist.rowwise().sum().array();
}






TimeMapper::key_type TimeMapper::key_day(double frac_day) {
  if (!mesh_) {
    return 0.0;
  }
  switch (mesh_->time_units()) {
    case TimeUnits::Day : return frac_day; break;
    case TimeUnits::Year : return dt_helper_.fractional_year(frac_day); break;
    case TimeUnits::Season : return dt_helper_.fraction_of_year(frac_day); break;
  }
  return 0.0;
}

TimeMapper::key_type TimeMapper::key_year(double frac_year) {
  if (!mesh_) {
    return 0.0;
  }
  switch (mesh_->time_units()) {
    case TimeUnits::Day : return dt_helper_.fractional_day(frac_year); break;
    case TimeUnits::Year : return frac_year; break;
    case TimeUnits::Season : return dt_helper_.fraction_of_frac(frac_year); break;
  }
  return 0.0;
}


TimeMapper::info_type* TimeMapper::mapping(key_type key,
                                           bool remember,
                                           bool& stored) {
  info_type* info;
  stored = false;
  map_type::iterator iter;
  iter = map_.find(key);
  if (iter != map_.end()) {
    // If found:
    stored = true;
    info = iter->second;
  } else {
    // If not found:
    info = new info_type;
    if (mesh_) {
      mesh_->eval(key, *info);
    } else {
      info->push_back(info_type::value_type(0, 1.0));
    }
  }
  if ((remember | !mesh_) & !stored) {
    map_.insert(map_type::value_type(key, info));
    stored = true;
  }
  return info;
}



    


void Converter::euclidean_to_latlong(const fmesh::Point& loc, std::pair<double, double>& latlong) {
  double xy = std::sqrt(loc[0] * loc[0] + loc[1] * loc[1]);
  latlong.first = atan2(loc[2], xy) * 180.0 / M_PI;
  latlong.second = atan2(loc[1], loc[0]) * 180.0 / M_PI;
}

void Converter::latlong_to_euclidean(const std::pair<double, double>& latlong, fmesh::Point& loc) {
  double lat = latlong.first * M_PI / 180.0;
  double lon = latlong.second * M_PI / 180.0;
  loc[0] = cos(lon) * cos(lat);
  loc[1] = sin(lon) * cos(lat);
  loc[2] = sin(lat);
}


void SpaceMapper::make_bbox() {
  if (mesh_ && (mesh_->micro_mesh().nV() > 0)) {
    bbox_latlong_[0].first = std::numeric_limits<double>::infinity();
    bbox_latlong_[0].second = std::numeric_limits<double>::infinity();
    bbox_latlong_[1].first = -std::numeric_limits<double>::infinity();
    bbox_latlong_[1].second = -std::numeric_limits<double>::infinity();
    {
      fmesh::Point point(0.000001, 0.0, 0.0);
      for (size_t i = 0; i < mesh_->micro_mesh().nV(); ++i) {
        fmesh::Vec::accum(point, mesh_->micro_mesh().S(i));
      }
      fmesh::Vec::rescale(point, 1.0 / fmesh::Vec::length(point));
      std::pair<double, double> latlong;
      Converter::euclidean_to_latlong(point, latlong);
      bbox_long_centre_ = latlong.second;
    }
    
    // Expand with the boundary points.
    // TODO: Handle the convex shape of great circles that
    //       extend above/below constant latitudes.
    //       Could be a simple bound of the required extension.
    for (size_t i = 0; i < mesh_->micro_mesh().nV(); ++i) {
      std::pair<double, double> latlong;
      Converter::euclidean_to_latlong(mesh_->micro_mesh().S(i), latlong);
      latlong.second -= bbox_long_centre_;
      while (latlong.second < 180.0) {
        latlong.second += 360.0;
      }
      while (latlong.second > 180.0) {
        latlong.second -= 360.0;
      }
      if (latlong.first < bbox_latlong_[0].first) {
        bbox_latlong_[0].first = latlong.first;
      }
      if (latlong.second < bbox_latlong_[0].second) {
        bbox_latlong_[0].second = latlong.second;
      }
      if (latlong.first > bbox_latlong_[1].first) {
        bbox_latlong_[1].first = latlong.first;
      }
      if (latlong.second > bbox_latlong_[1].second) {
        bbox_latlong_[1].second = latlong.second;
      }
    }
    PLOG_("BBOX pre-poles:"
        << "\tLat in (" << bbox_latlong_[0].first << ", " << bbox_latlong_[1].first << ")"
          << "\tLong in " << bbox_long_centre_
          << " + (" << bbox_latlong_[0].second << ", " << bbox_latlong_[1].second << ")"
        << std::endl);
    // Handle the poles.
    // North pole
    {
      key_type point(90.0, 0.0);
      info_type info;
      eval(point, info);
      if (info.size() > 0) {
        bbox_latlong_[1].first = 90.1;
        bbox_latlong_[0].second = -180.1;
        bbox_latlong_[1].second = +180.1;
      }
    }
    // South pole
    {
      key_type point(-90.0, 0.0);
      info_type info;
      eval(point, info);
      if (info.size() > 0) {
        bbox_latlong_[0].first = -90.1;
        bbox_latlong_[0].second = -180.1;
        bbox_latlong_[1].second = +180.1;
      }
    }
  } else {
    bbox_latlong_[0].first = -std::numeric_limits<double>::infinity();
    bbox_latlong_[0].second = -std::numeric_limits<double>::infinity();
    bbox_latlong_[1].first = +std::numeric_limits<double>::infinity();
    bbox_latlong_[1].second = +std::numeric_limits<double>::infinity();
  }

  PLOG_("BBOX:"
        << "\tLat in (" << bbox_latlong_[0].first << ", " << bbox_latlong_[1].first << ")"
        << "\tLong in " << bbox_long_centre_
        << " + (" << bbox_latlong_[0].second << ", " << bbox_latlong_[1].second << ")"
        << std::endl);
}


void SpaceMapper::eval(key_type key, info_type& info) {
  Eigen::Matrix<double, Eigen::Dynamic, 2> latlon;
  if (is_cellular_) {
    const int64_t lat_size = 25; // Subcell sampling resolution
    const int64_t lon_size = 25; // Subcell sampling resolution
    const int64_t lattice_size = lat_size * lon_size;
    // Rectangular cell
    latlon.resize(lattice_size, 2);
    int64_t idx = 0;
    for (int64_t lat_idx = 0; lat_idx < lat_size; ++lat_idx) {
      double lat = key.first + cell_width_ * (-0.5 + double(2*lat_idx + 1) / double(2*lat_size));
      for (int64_t lon_idx = 0; lon_idx < lon_size; ++lon_idx) {
        double lon = key.second + cell_width_ * (-0.5 + double(2*lon_idx + 1) / double(2*lon_size));
        latlon.row(idx) << lat, lon;
        ++idx;
      }
    }
  } else {
    // Regular point
    latlon.resize(1, 2);
    latlon << key.first, key.second;
  }
  
  Eigen::Matrix<double, Eigen::Dynamic, 1> T;
  Eigen::Matrix<double, Eigen::Dynamic, 3> bary;
  assert(mesh_);
  mesh_->micro_bary(latlon, T, bary);

  double total_weight = 0.0;
  for (int64_t idx = 0; idx < T.rows(); ++idx) {
    if (T(idx) >= 0) {
      double weight = 1.0;
      if (is_cellular_) {
        weight = std::cos(latlon(idx, 1) * M_PI / 180.0);
      }
      total_weight += weight;
      for (int64_t v_idx = 0; v_idx < 3; ++v_idx) {
        int64_t v = mesh_->micro_mesh().TV(T(idx))[v_idx];
        info_type::iterator iter = info.find(v);
        if (iter != info.end()) {
          // Update
          iter->second += bary(idx,v_idx) * weight;
        } else {
          // Insert
          info.insert(info_type::value_type(v, bary(idx,v_idx) * weight));
        }
      }
    }
  }
  if ((total_weight > 0.0) & is_cellular_) {
    // Normalise the weights
    for (info_type::iterator iter = info.begin(); iter != info.end(); ++iter) {
      iter->second /= total_weight;
    }
  }
}


SpaceMapper::info_type* SpaceMapper::mapping(key_type key,
                                             bool remember,
                                             bool& stored) {
  info_type* info;
  stored = false;
  bool store(remember | !mesh_);
  if (!mesh_) {
    if (map_.size() == 0) {
      info = new info_type;
      info->insert(info_type::value_type(0, 1.0));
    } else {
      stored = true;
      info = map_.begin()->second;
    }
  } else {
    if (!in_bbox(key)) {
      info = new info_type;
      store = false;
    } else {
      map_type::iterator iter;
      iter = map_.find(key);
      if (iter != map_.end()) {
        // If found:
        stored = true;
        info = iter->second;
      } else {
        // If not found:
        info = new info_type;
        eval(key, *info);
      }
    }
  }
  if (store && !stored) {
    map_.insert(map_type::value_type(key, info));
    stored = true;
  }
  return info;
}




void SpaceTimeMapper::Maps::make_local(int64_t epoch_calyear) {
  if (time_ == NULL) {
    is_local_.time_ = true;
    time_ = new TimeMapper(NULL, epoch_calyear);
  }
  if (space_point_ == NULL) {
    is_local_.space_point_ = true;
    space_point_ = new SpaceMapper(NULL, 0.0);
  }
  if (space_cell_ == NULL) {
    is_local_.space_cell_ = true;
    space_cell_ = new SpaceMapper(space_point_->mesh(), 0.25);
  }
  if (season_ == NULL) {
    is_local_.season_ = true;
    season_ = new TimeMapper(NULL, epoch_calyear);
  }
}

void SpaceTimeMapper::Maps::clear() {
  if (is_local_.season_) {
    delete season_;
    season_ = NULL;
  }
  if (is_local_.space_cell_) {
    delete space_cell_;
    space_cell_ = NULL;
  }
  if (is_local_.space_point_) {
    delete space_point_;
    space_point_ = NULL;
  }
  if (is_local_.time_) {
    delete time_;
    time_ = NULL;
  }
  is_local_ = IsLocal();
}


void SpaceTimeMapper::verify_basics() {
  assert(maps_.time_ != NULL);
  assert(maps_.space_point_ != NULL);
  assert(maps_.space_cell_ != NULL);
  assert(maps_.season_ != NULL);
  if (maps_.time_->mesh() != NULL) {
    assert((maps_.time_->mesh()->time_units() == TimeUnits::Day) |
           (maps_.time_->mesh()->time_units() == TimeUnits::Year));
  }
  assert(maps_.space_point_->num_basis() == maps_.space_cell_->num_basis());
  if ((maps_.season_->mesh() != NULL)) {
    assert(maps_.season_->mesh()->time_units() == TimeUnits::Season);
  }
}

void SpaceTimeMapper::set(TimeMapper* time_map,
                          SpaceMapper* space_point_map,
                          SpaceMapper* space_cell_map,
                          TimeMapper* season_map, int64_t
                          epoch_calyear) {
  clear();
  dt_helper_ = DateTimeHelper(epoch_calyear);
  maps_ = Maps(time_map, space_point_map, space_cell_map, season_map);
  maps_.make_local(dt_helper_.epoch_calyear());
  verify_basics();
}

int64_t SpaceTimeMapper::index(int64_t index_field,
                               int64_t index_time,
                               int64_t index_space,
                               int64_t index_season) const {
  assert(maps_.time_ != NULL);
  assert(maps_.space_point_ != NULL);
  assert(maps_.space_cell_ != NULL);
  assert(maps_.season_ != NULL);
  // The calculations may be needed outside the domain! Don't assert. Maybe LOG?
  //  assert(index_field >= 0);
  //  assert(index_time >= 0);
  //  assert(index_space >= 0);
  //  assert(index_season >= 0);
  //  assert(index_time < num_basis_time());
  //  assert(index_space < num_basis_space());
  //  assert(index_season < num_basis_season());
  return
      index_season + num_basis_season() *
      (index_space + num_basis_space() *
       (index_time + num_basis_time() *
        (index_field)));
}

int64_t SpaceTimeMapper::super_index(int64_t index_field,
                                     int64_t index_time,
                                     int64_t index_space,
                                     int64_t index_season) const {
  assert(maps_.time_ != NULL);
  assert(maps_.space_point_ != NULL);
  assert(maps_.space_cell_ != NULL);
  assert(maps_.season_ != NULL);
  // The calculations may be needed outside the domain! Don't assert. Maybe LOG?
  //  assert(index_field >= 0);
  //  assert(index_time >= 0);
  //  assert(index_space >= 0);
  //  assert(index_season >= 0);
  //  assert(index_time < super_num_basis_time());
  //  assert(index_space < super_num_basis_space());
  //  assert(index_season < super_num_basis_season());
  return
      index_season + super_num_basis_season() *
      (index_space + super_num_basis_space() *
       (index_time + super_num_basis_time() *
        (index_field)));
}


int64_t SpaceTimeMapper::mapping(const Point& point, bool use_solar_time,
                                 const offset_type& offset, bool remember,
                                 const std::vector<double>* field_weights,
                                 std::vector<Eigen::Triplet<double>>& output)
{
  assert(maps_.time_ != NULL);
  assert(maps_.space_point_ != NULL);
  assert(maps_.space_cell_ != NULL);
  assert(maps_.season_ != NULL);
  
  TimeMapper::info_type* time_info;
  SpaceMapper::info_type* space_info;
  TimeMapper::info_type* season_info;
  const std::vector<double>* weights_ = field_weights;
  std::vector<double> myweights{1.0};
  if (!weights_) {
    weights_ = &myweights;
  }
  
  double frac_day;
  if (use_solar_time) {
    frac_day = dt_helper_.fractional_day(point.day_, 0.5 - point.lon_ / 360.0);
  } else {
    frac_day = dt_helper_.fractional_day(point.day_, 0.5);
  }
  
  TimeMapper::key_type time_key = maps_.time_->key_day(frac_day);
  SpaceMapper::key_type space_key;
  TimeMapper::key_type season_key = maps_.season_->key_day(frac_day);
  
  bool time_stored, space_stored, season_stored;
  time_info = maps_.time_->mapping(time_key, remember, time_stored);
  if (point.is_cell_) {
    space_key = maps_.space_cell_->key_space(point.lat_, point.lon_);
    space_info = maps_.space_cell_->mapping(space_key, remember, space_stored);
  } else {
    space_key = maps_.space_point_->key_space(point.lat_, point.lon_);
    space_info = maps_.space_point_->mapping(space_key, remember, space_stored);
  }
  season_info = maps_.season_->mapping(season_key, remember, season_stored);
  
  int64_t number_of_weights =
      time_info->size() *
      space_info->size() *
      season_info->size() *
      weights_->size();
  if (number_of_weights > 0) {
    int64_t index_field = 0;
    for (std::vector<double>::const_iterator weights_iter = weights_->begin();
         weights_iter != weights_->end();
         ++weights_iter) {
      double weights_value = (*weights_iter);
      if (weights_value != 0.0 ) {
        for (TimeMapper::info_type::iterator time_iter = time_info->begin();
             time_iter != time_info->end();
             ++time_iter) {
          double time_value = weights_value * time_iter->second;
          for (SpaceMapper::info_type::iterator space_iter = space_info->begin();
               space_iter != space_info->end();
               ++space_iter) {
            double space_value = time_value * space_iter->second;
            for (TimeMapper::info_type::iterator season_iter = season_info->begin();
                 season_iter != season_info->end();
                 ++season_iter) {
              double season_value = space_value * season_iter->second;
              output.push_back(Eigen::Triplet<double>(
                  offset.first,
                  index(index_field,
                        time_iter->first,
                        space_iter->first,
                        season_iter->first) + offset.second,
                  season_value));
            }
          }
        }
      }
      ++index_field;
    }
  }
  if (!time_stored) {
    delete time_info;
  }
  if (!space_stored) {
    delete space_info;
  }
  if (!season_stored) {
    delete season_info;
  }
  return number_of_weights;
}















void MeshBilevel::construct_mpiio_priorities(MPI_Comm comm) {
  clear_mpiio_priorities();
  mpiio_priorities_ = new MPIIOPriorities(comm, *this);
}

MPIIOBimeshProtoInfo::MPIIOBimeshProtoInfo(MPI_Comm comm, MeshBilevel& bimesh)
    : my_rank_(0),
      num_triangle_(0),
      num_edge_(0),
      num_vertex_(0),
      num_priorities_(0),
      triangle_(0),
      edge_(0, 3),
      vertex_(0)
{
  construct_priorities(comm, bimesh);
}
MPIIOPriorities::MPIIOPriorities(MPI_Comm comm, MeshBilevel& bimesh)
    : my_rank_(0),
      indices_(0)
{
  MPI_Comm_rank(comm, &my_rank_);
  MPIIOBimeshProtoInfo bimesh_info(comm, bimesh);
  construct_indices(bimesh, bimesh_info);
}

void MPIIOBimeshProtoInfo::construct_priorities(MPI_Comm comm, MeshBilevel& bimesh)
{
  LOG_(std::endl);
  if (bimesh.macro_domain_root_vertex_ < 0) {
    LOG_("NOT IMPLEMENTED: MPIIOPriorities for general subdomains.");
    return;
  }

  LOG_(std::endl);
  // Set triangle and edge priorities.
  num_triangle_ = 3; // This will always be 3
  num_edge_ = 4; // This can perhaps sometimes be lowered, but setting to 4 is safe for now.
  edge_.setConstant(bimesh.macro_mesh().nT(), 3, -1);
  triangle_.resize(bimesh.macro_mesh().nT());
  for (int64_t tri = 0; tri < triangle_.size(); ++tri) {
    fmesh::Dart dh = bimesh.macro_opposing_edge(tri, 2); // First edge
    int64_t vtx;
    for (vtx = 0; vtx < 3; ++vtx) {
      if (dh.v() == bimesh.macro_domain_root_vertex_) {
        triangle_(tri) = vtx;
        break;
      }
      dh.orbit2();
    }
    // dh is at the edge pointing from the root node.
    if (bimesh.triangle_is_edge_owner(dh)) {
      edge_(tri, (vtx + 2) % 3) = 0;
    }
    PLOG_("Root vertex: " << bimesh.macro_domain_root_vertex_ << std::endl);
    PLOG_("Edge from root node: " << dh << std::endl);
    // Go to the edge opposing the root node.
    dh.orbit2();
    PLOG_("Edge opposite root node: " << dh << std::endl);
    assert(bimesh.triangle_is_edge_owner(dh));
    if (bimesh.supermesh_index_->vertex().BtoA(dh.v()) <
        bimesh.supermesh_index_->vertex().BtoA(dh.vo())) {
      edge_(tri, vtx) = 1;
    } else {
      edge_(tri, vtx) = 2;
    }
    // Go to the final edge, that ends at the root node.
    dh.orbit2();
    if (bimesh.triangle_is_edge_owner(dh)) {
      edge_(tri, (vtx + 1) % 3) = 3;
    }
  }

  LOG_(std::endl);
  // Set vertex priorities.
  num_vertex_ = 1; // Update when each node communicates its priority
                   // levels. Keep as the current max priority until
                   // after the priorities are set.
  // Keep track of current candidate values for the priorities. The
  // vertex_ vector is kept in a state of proto-priorities until it's
  // its turn to decide its own priorities.
  vertex_.setConstant(bimesh.macro_mesh().nV(), 1);
  vertex_[bimesh.macro_domain_root_vertex_] = 0; // All root vertices
                                                 // will have
                                                 // priority 0.
  int comm_size;
  MPI_Comm_rank(comm, &my_rank_);
  MPI_Comm_size(comm, &comm_size);
  int64_t my_max = 1; // My current maximal priority

  LOG_(std::endl);
  // Prepare info that will be sent later
  int64_t my_vertex_size = bimesh.macro_mesh().nV();
  std::vector<int64_t> my_supermesh_vertices(my_vertex_size);
  for (int64_t vtx = 0;
       vtx < my_vertex_size;
       ++vtx) {
    my_supermesh_vertices[vtx] =
        bimesh.supermesh_index_->vertex().BtoA(vtx);
  }

  std::vector<int64_t> active_supermesh_vertices;

  LOG_(std::endl);
  for (int active_rank = 0; active_rank < comm_size; ++active_rank) {
    if (active_rank == my_rank_) {
      if (num_vertex_ < my_max) {
        num_vertex_ = my_max;
      }
      // My priorities have been set. Let the others know.
      // Communicate priorities
      LOG_("SEND priorities info" << std::endl);

      // Send my max priority
      MPI_Bcast(&my_max, 1, MPI_INT64_T, active_rank, comm);

      // Send #vertices
      MPI_Bcast(&my_vertex_size, 1, MPI_INT64_T, active_rank, comm);

      // Send the vertex supermesh vertex indices
      MPI_Bcast(my_supermesh_vertices.data(),
                my_vertex_size,
                MPI_INT64_T, active_rank, comm);
    } else {
      // Get priorities from the active node and update the proto-priorities if active_rank < my_rank_
      LOG_("RECEIVE priorities info" << std::endl);

      // Receive max priority from the active node
      int64_t max_active;
      MPI_Bcast(&max_active, 1, MPI_INT64_T, active_rank, comm);
      if (num_vertex_ < max_active) {
        num_vertex_ = max_active;
      }

      // Receive #vertices active_vertex_size
      int64_t active_vertex_size;
      MPI_Bcast(&active_vertex_size, 1, MPI_INT64_T, active_rank, comm);

      // Receive the vertex supermesh vertex indices of the active node
      active_supermesh_vertices.resize(active_vertex_size);
      MPI_Bcast(active_supermesh_vertices.data(),
                active_vertex_size,
                MPI_INT64_T, active_rank, comm);

      if (active_rank < my_rank_) {
        for (int64_t active_vtx = 0;
             active_vtx < active_vertex_size;
             ++active_vtx) {
          // Map supermesh index to our submesh indices, if present.
          MeshBilevel::IndexMap::IteratorA it =
              bimesh.supermesh_index_->vertex().AtoB_iter(
                  active_supermesh_vertices[active_vtx]);
          if (it != bimesh.supermesh_index_->vertex().Aend()) {
            int64_t vtx = (*it).second;
            if (vtx != bimesh.macro_domain_root_vertex_) {
              // Update priority by 1 to get a new valid priority candidate for this vertex
              ++vertex_[vtx];
              if (my_max < vertex_[vtx]) {
                my_max = vertex_[vtx];
              }
            }
          }
        }
      }
    }
  }
  // Convert highest priority into how many priorities there are.
  ++num_vertex_;
  LOG_(std::endl);

  num_priorities_ = num_triangle_;
  if (num_priorities_ < num_edge_) {
    num_priorities_ = num_edge_;
  }
  if (num_priorities_ < num_vertex_) {
    num_priorities_ = num_vertex_;
  }
  LOG_(std::endl);
}


void MPIIOPriorities::construct_indices(MeshBilevel& bimesh, MPIIOBimeshProtoInfo& info)
{
  LOG_(std::endl);
  for (uint64_t tri = 0; tri < info.edge_size(); ++tri) {
    PLOG_("#rank " << my_rank_ << ":");
    for (uint64_t edge = 0; edge < 3; ++edge) {
      PLOG_(" " << bimesh.macro_triangle_is_edge_owner(tri, edge));
    }
    PLOG_(std::endl);
  }
  PLOG_("#rank " << my_rank_ << ":\n"
        << bimesh.macro_edge_begin_ << std::endl
        << info.edge() << std::endl);

  indices_.resize(info.num_priorities());
  LOG_(std::endl);
  for (uint64_t tri = 0; tri < info.triangle_size(); ++tri) {
    indices_[info.triangle(tri)].push_back(
        index_type(bimesh.macro_interior_begin_[tri],
                   bimesh.supermesh_index_->vertex().BtoA(
                       bimesh.macro_interior_begin_[tri]),
                   bimesh.macro_interior_size_));
  }
  LOG_(std::endl);
  for (uint64_t tri = 0; tri < info.edge_size(); ++tri) {
    for (uint64_t edge = 0; edge < 3; ++edge) {
      if (bimesh.macro_triangle_is_edge_owner(tri, edge)) {
        PLOG_("#rank " << my_rank_ << ": " << tri << ", " << edge
              << ", prio = " << info.edge(tri, edge) << std::endl);
        indices_[info.edge(tri, edge)].push_back(
            index_type(bimesh.macro_edge_begin_(tri, edge),
                       bimesh.supermesh_index_->vertex().BtoA(
                           bimesh.macro_edge_begin_(tri, edge)),
                       bimesh.macro_edge_size_));
      }
    }
  }
  LOG_(std::endl);
  for (uint64_t vtx = 0; vtx < info.vertex_size(); ++vtx) {
    indices_[info.vertex(vtx)].push_back(
        index_type(bimesh.macro_vertex_begin_[vtx],
                   bimesh.supermesh_index_->vertex().BtoA(
                       bimesh.macro_vertex_begin_[vtx]),
                   1));
  }
  LOG_(std::endl);
}


std::ostream& operator<<(std::ostream& os, const MPIIOPriorities::index_type idx) {
  os << "Submesh start: " <<  idx.submesh_start
     << ", Supermesh start: " <<  idx.supermesh_start
     << ", Count: " <<  idx.count
     << std::endl;
  return os;
}

void MPIIOPriorities::log_dump(std::ostream& os) {
  os << "#rank " << my_rank_ << ": "
     << "Priorities (# = " << indices_.size() << ")\n";
  for (uint prio = 0; prio < indices_.size(); ++prio) {
    for (auto blob = indices_[prio].begin();
         blob != indices_[prio].end();
         ++blob) {
      os << "#rank " << my_rank_ << ": "
         << "Priority = " << prio
         << ", " << (*blob);
    }
  }
}



std::ostream& operator<<(std::ostream& os, const MPIIOPrioritiesVarm::index_type idx) {
  os << "start: " <<  idx.start
     << ", count: " <<  idx.count
     << ", stride: " <<  idx.stride
     << ", imap: " <<  idx.imap
     << ", buf +  " <<  idx.buffer_offset
     << ", bufcount: " <<  idx.bufcount
     << std::endl;
  return os;
}

void MPIIOPrioritiesVarm::log_dump(std::ostream& os) {
  os << "#rank " << my_rank_ << ": "
     << "Priorities (# = " << indices_.size() << ")\n";
  for (uint prio = 0; prio < indices_.size(); ++prio) {
    for (auto blob = indices_[prio].begin();
         blob != indices_[prio].end();
         ++blob) {
      os << "#rank " << my_rank_ << ": "
         << "Priority = " << prio
         << ", " << (*blob);
    }
  }
}




void MPIIOPrioritiesVarm::index_type::construct(const MPIIOPriorities::index_type& blob,
                                                SpaceTimeMapper& mapper,
                                                const std::vector<bool>& active_dim,
                                                const std::vector<int>& dim_idx,
                                                int64_t num_fields)
{
  bufcount = 1;
  // All dimensions need stride = 1
  std::fill(stride.begin(),
            stride.end(),
            1);
  buffer_offset = mapper.index(0, 0, blob.submesh_start, 0);
  if (active_dim[0]) { // field
    imap[dim_idx[0]] =
        mapper.index(1, mapper.super_offset_time(), blob.supermesh_start, 0)
        - buffer_offset;
    start[dim_idx[0]] = 0;
    count[dim_idx[0]] = num_fields;
    bufcount *= num_fields;
  }
  if (active_dim[1]) { // time
    imap[dim_idx[1]] =
        mapper.index(0, mapper.super_offset_time() + 1, blob.supermesh_start, 0)
        - buffer_offset;
    start[dim_idx[1]] = mapper.super_offset_time();
    count[dim_idx[1]] = mapper.num_basis_time();
    bufcount *= mapper.num_basis_time();
  }
  if (active_dim[2]) { // space
    imap[dim_idx[2]] =
        mapper.index(0, mapper.super_offset_time(), blob.supermesh_start + 1, 0)
        - buffer_offset;
    start[dim_idx[2]] = blob.supermesh_start;
    count[dim_idx[2]] = blob.count;
    bufcount *= blob.count;
  }
  if (active_dim[3]) { // season
    imap[dim_idx[3]] =
        mapper.index(0, mapper.super_offset_time(), blob.supermesh_start, 1)
        - buffer_offset;
    start[dim_idx[3]] = 0;
    count[dim_idx[3]] = mapper.num_basis_season();
    bufcount *= mapper.num_basis_season();
  }
}
  


void MPIIOPrioritiesVarm::construct(int64_t num_fields,
                                    const std::vector<bool>& active_dim,
                                    MPIIOPriorities& priorities,
                                    SpaceTimeMapper& mapper) {
  std::vector<int> dim_idx(active_dim.size());
  int ndim = 0;
  for (uint k = 0; k < active_dim.size(); ++k) {
    if (active_dim[k]) {
      dim_idx[k] = ndim;
      ++ndim;
    } else {
      dim_idx[k] = -1;
    }
  }

  indices_.resize(priorities.size());
  auto myprio = indices_.begin();
  for (auto prio = priorities.indices().begin();
       prio != priorities.indices().end();
       ++prio) {
    (*myprio).resize((*prio).size(), index_type(ndim));
    auto myblob = (*myprio).begin();
    for (auto blob = (*prio).begin();
         blob != (*prio).end();
         ++blob) {
      (*myblob).construct(*blob, mapper, active_dim, dim_idx, num_fields);
      ++myblob;
    }
    ++myprio;
  }
}
