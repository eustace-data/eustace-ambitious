// Based on example code Copyright Vladimir Prus 2002-2004.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt
// or copy at http://www.boost.org/LICENSE_1_0.txt)

/* Shows how to use both command line and config file. */

#include "ambitious/versions/versions.hpp"
VERSIONS_ADD(po_tool_cpp, "$Revision: 1258 $")

#include "ambitious/debuglog/debuglog.hpp"
#include "ambitious/ostreamer/ostreamer.hpp"

#include "ambitious/po_tool/po_tool.hpp"
namespace po = boost::program_options;



/** Based on code from https://gist.github.com/gesquive/8673796 */

void CommandlineBase::PrintVariableMap(std::ostream & output_stream) {
  output_stream << "## Configuration generated by " << program_name_ << ", version " << program_version_ << std::endl;
  for (po::variables_map::iterator it = vm_.begin(); it != vm_.end(); it++) {
    
    if (config_file_options_.find_nothrow(it->first, false, false, false) == NULL) {
      // output_stream << "# " << it->first << " not allowed in config file." << std::endl;
      continue;
    }
    
    output_stream << it->first << "=";
    
    bool is_char;
    try {
      boost::any_cast<const char *>(it->second.value());
      is_char = true;
    } catch (const boost::bad_any_cast &) {
      is_char = false;
    }
    bool is_str;
    try {
      boost::any_cast<std::string>(it->second.value());
      is_str = true;
    } catch (const boost::bad_any_cast &) {
      is_str = false;
    }
    
    if (((boost::any)it->second.value()).type() == typeid(int)) {
      output_stream << vm_[it->first].as<int>();
    } else if (((boost::any)it->second.value()).type() == typeid(uint64_t)) {
      output_stream << vm_[it->first].as<uint64_t>();
    } else if (((boost::any)it->second.value()).type() == typeid(int64_t)) {
      output_stream << vm_[it->first].as<int64_t>();
    } else if (((boost::any)it->second.value()).type() == typeid(bool)) {
      output_stream << vm_[it->first].as<bool>();
    } else if (((boost::any)it->second.value()).type() == typeid(double)) {
      output_stream << vm_[it->first].as<double>();
    } else if (((boost::any)it->second.value()).type() == typeid(float)) {
      output_stream << vm_[it->first].as<float>();
    } else if (is_char) {
      output_stream << vm_[it->first].as<const char * >();
    } else if (is_str) {
      std::string temp = vm_[it->first].as<std::string>();
      if (temp.size()) {
	output_stream << temp;
      } else {
	output_stream << "true";
      }
    } else { // Assumes that the only remainder is vector<string>
      try {
	std::vector<std::string> vect = vm_[it->first].as<std::vector<std::string> >();
	ostream_copy_vec(output_stream, vect);
      } catch (const boost::bad_any_cast &) {
	output_stream << "UnknownType(" << ((boost::any)it->second.value()).type().name()
                      << ")";
      }
    }
    
    if (((boost::any)it->second.value()).empty()) {
      output_stream << " # empty";
    }
    if (vm_[it->first].defaulted() || it->second.defaulted()) {
      output_stream << " # default";
    }
    
    output_stream << std::endl;
  }
  output_stream << "## End of generated configuration" << std::endl;
}

CommandlineBase::CommandlineBase(int ac, char* av[],
                                 const std::string& config_file)
    : config_file_(config_file),
      config_file_out_("--"),
      generic_("Generic options"),
      config_("Configuration options"),
      hidden_("Hidden options"),
      positional_(),
      cmdline_options_("All options"),
      config_file_options_("Config file options"),
      visible_(""),
      ac_(ac), av_(av),
      program_name_("example"),
      program_version_("0.0"),
      recommended_return_value_(0)
{
  add_base_generic();
}

CommandlineBase::CommandlineBase(int ac, char* av[],
                                 const std::string& config_file,
                                 const std::string& program_name,
                                 const std::string& program_version)
    : config_file_(config_file),
      config_file_out_("--"),
      generic_("Generic options"),
      config_("Configuration options"),
      hidden_("Hidden options"),
      positional_(),
      cmdline_options_("All options"),
      config_file_options_("Config file options"),
      visible_(""),
      ac_(ac), av_(av),
      program_name_(program_name),
      program_version_(program_version),
      recommended_return_value_(0)
{
  add_base_generic();
}

void CommandlineBase::add_base_generic() {
  // Declare a group of options that will be allowed only on command
  // line
  generic_.add_options()
    ("version,v", "print version string")
    ("help", "produce help message")
    ("config,c", po::value<std::string>(&config_file_)->default_value(config_file_),
     "name of an configuration input file. Use -- for stdin.")
    ("config-print,C", po::value<std::string>(&config_file_out_)->default_value(config_file_out_),
     "print the config options in config file format. Use -- for stdout.")
    (",X", "terminate after printing the version and/or options.")
    ;
  
  // Declare a group of options that will be allowed both on command
  // line and in config file
  // config_.add_options();
  
  // Hidden options, will be allowed both on command line and
  // in config file, but will not be shown to the user.
  //    hidden_.add_options();
  
}


void CommandlineBase::process_config_file(std::istream &input_stream) {
  if (!input_stream) {
    if (vm_.count("config") && !vm_["config"].defaulted()) {
      // Do not ignore explicitly specified config file
      throw std::runtime_error(std::string("Missing config file '") +
			       config_file_ + std::string("'."));
    } else {
      // Ignore missing default config file
      // std::cout << "Config file not found: " << config_file_ << " (ignored)" << std::endl;
    }
  } else {
    store(parse_config_file(input_stream, config_file_options_), vm_);
    notify(vm_);
  }
}

void CommandlineBase::process() {
  if (is_processed_) {
    throw std::runtime_error("Error: process() called multiple times!");
  }
LOG_(std::endl);
  cmdline_options_.add(generic_).add(config_).add(hidden_);
LOG_(std::endl);
  config_file_options_.add(config_).add(hidden_);
LOG_(std::endl);
  visible_.add(generic_).add(config_);
LOG_(std::endl);
  
//  store(po::command_line_parser(ac_, av_).
//	options(cmdline_options_).positional(positional_).run(), vm_);
LOG_(std::endl);
 po::command_line_parser parser{ac_, av_};
LOG_(std::endl);
 parser.options(cmdline_options_).positional(positional_);
LOG_(std::endl);
 po::parsed_options parsed_options = parser.run();
LOG_(std::endl);
  store(parsed_options, vm_);
LOG_(std::endl);
  notify(vm_);
LOG_(std::endl);

  if (config_file_.compare(std::string("--")) == 0) {
LOG_(std::endl);
    process_config_file(std::cin);
LOG_(std::endl);
  } else {
LOG_(std::endl);
    std::ifstream ifs(config_file_.c_str());
LOG_(std::endl);
    process_config_file(ifs);
LOG_(std::endl);
  }
LOG_(std::endl);
  is_processed_ = true;
LOG_(std::endl);
}

int CommandlineBase::handle_help() {
  if (!is_processed_) process();
  if (vm_.count("help")) {
    std::cout << "Usage: " << av_[0] << " [options]";
    for (positional_list_class::const_iterator i = positional_list_.begin();
	 i != positional_list_.end();
	 ++i) {
      if (i->second == 1) {
	std::cout << " " << i->first;
      } else {
	std::cout << " " << i->first << "1";
	if (i->second > 2 || i->second == -1) {
	  std::cout << " " << "...";
	}
	if (i->second != -1) {
	  std::cout << " " << i->first << i->second;
	}
      }
    }
    std::cout << std::endl;
    std::cout << visible_ << std::endl;
    return 1;
  } else {
    return 0;
  }
}

void CommandlineBase::set_name_version(const std::string& program_name,
                                       const std::string& program_version) {
  program_name_ = program_name;
  program_version_ = program_version;
}

int CommandlineBase::handle_version() {
  if (!is_processed_) process();
  if (vm_.count("version")) {
    std::cout << program_name_ << " " << program_version_ << std::endl;
    return 1;
  } else {
    return 0;
  }
}

int CommandlineBase::handle_printconfig() {
  if (!is_processed_) process();
  if (vm_.count("config-print")) {
    if (config_file_out_.compare(std::string("--")) == 0) {
      std::ostream out(std::cout.rdbuf());
      PrintVariableMap(out);
    } else {
      std::ofstream out(config_file_out_, std::ofstream::out);
      PrintVariableMap(out);
      out.close();
    }
    return 1;
  }
  return 0;
}

int CommandlineBase::handle_base_options() {
  recommended_return_value_ = 0;
  int return_ = 0;
  if (!is_processed_) process();
  if (handle_version()) {
  }
  if (handle_printconfig()) {
  }
  if (handle_help()) {
    return_ = 1;
  }
  if (vm_.count("-X")) {
    return_ = 1;
  }
  return return_;
}

int CommandlineBase::handle_options() {
  LOG_(std::endl);
  try{
    if (handle_base_options()) {
      LOG_(std::endl);
      return 1; // Intentional abort recommendation.
    }
    LOG_(std::endl);
  }
  catch(std::exception& e)
  {
    LOG_(std::endl);
    std::cout << e.what() << std::endl;
    LOG_(std::endl);
    recommended_return_value_ = 1;
    return 1; // An error occurred.
  }    
  LOG_(std::endl);
  return 0;
}




po::options_description_easy_init CommandlineBase::add_generic() {
  if (is_processed_) {
    throw std::runtime_error("Error: Cannot add more generic options after calling process()!");
  }
  return generic_.add_options();
}
po::options_description_easy_init CommandlineBase::add_config() {
  if (is_processed_) {
    throw std::runtime_error("Error: Cannot add more config options after calling process()!");
  }
  return config_.add_options();
}
po::options_description_easy_init CommandlineBase::add_hidden() {
  if (is_processed_) {
    throw std::runtime_error("Error: Cannot add more hidden options after calling process()!");
  }
  return hidden_.add_options();
}

void CommandlineBase::add_positional(const char * name, int max_count) {
  if (is_processed_) {
    throw std::runtime_error("Error: Cannot add more positional options after calling process()!");
  }
  positional_.add(name, max_count);
  positional_list_.push_back(std::pair< std::string, int >(std::string(name), max_count));
}


unsigned CommandlineBase::positional_max_total_count() const {
  return positional_.max_total_count();
}
const std::string & CommandlineBase::positional_name_for_position(unsigned position) const {
  return positional_.name_for_position(position);
}
